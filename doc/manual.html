<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>PyDO2 Manual</title>
<meta name="author" content="Jacob Smullyan &lt;smulloni&#64;smullyan.org&gt;" />
<meta name="date" content="2005-11-17 14:43:33 -0500 (Thu, 17 Nov 2005)" />
<style type="text/css">

body {
  margin-top: 5px;
  margin-left: 50px;
  margin-right: 50px;
  width: 750px;
  
  padding: 0;
  border: 0;
  color: #530;

  font: 10pt verdana, "Bitstream Vera Sans", geneva, arial, helvetica, helve, sans-serif; 
}

/* em {
  font-family: Times New Roman, Times, serif;
}*/

#table-of-contents { 
  margin-top: 0px;
 }


a.target {
  color: blue }

a.toc-backref {
  text-decoration: none ;
  color: black }

a:hover {
  /* background-color: #cccccc; */
}

cite {
  font-style: normal;
  font-family: monospace;
  font-weight: bold;
}

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning {
  margin-left: 4em ;
  padding: 8px;
  text-align: justify;
  font-size: smaller;
  width: 80%;
  border-top: 1px dashed #d33;
  border-bottom: 1px dashed #d33;


 }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif;
  text-align: center }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif;
  text-align: center }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1, h2, h3, h4, h5, h6 {
  /* font-family: Helvetica, Arial, sans-serif; */
  /* border: thin solid black; */
  /* -moz-border-radius: 4px; */
  padding: 4px;
  /* background-color: lightgrey; */
 }

/* h1 {
  background-color: lightgrey;
  border: medium solid black;
  color: #ffffff;
}

h2 {
  background-color: #666666;
  color: #ffffff;
  border: medium solid black;
}

h3, h4, h5, h6 {
  background-color: #cccccc;
  color: #000000;
}
*/

h1.title {
  text-align: center;
  /* background-color: #444499; */
  color: #000;
  border-bottom: thick solid black;
  /* border: thick solid black; */
  /* -moz-border-radius: 20px; */
 }

h2.subtitle {
  text-align: center }

hr {
  width: 75% }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p { 
 text-align: justify;
 }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.first {
  margin-top: 0 }

p.label {
  white-space: nowrap }

p.topic-title {
  font-weight: bold }

pre { 
   font-size: smaller;
    }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #EEE;
  border: thin black solid;
  padding: 5px;
}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  font-size: 80%;
  margin-bottom: 25px;
  padding-bottom: 0;
}

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

td > p:first-child, th > p:first-child {
  margin-top: 0em }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 80%; }

tt {
  //background-color: #eeeeee;
  color: #000066 }

ul.auto-toc {
  list-style-type: none;
  font-size: 90%;

}

// Highlighting:

.function {color: #000077; font-weight: bold}
.keyword {color: #004444;}
.comment {color: #770000; font-style: italic}
.normal {color: #000000;}
.string {color: #006600;}
.symbol {color: #000000;}

.htmltag {color: #000077;}
.htmlsymbol {color: #000000;}
.htmlnormal {color: #000000;}
.htmlcomment {color: #770000; font-style: italic}
.htmlstring {color: #006600;}
.htmlattr {color: #000000;}


</style>
</head>
<body>
<div class="document" id="pydo2-manual">
<h1 class="title">PyDO2 Manual</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Jacob Smullyan &lt;<a class="reference" href="mailto:smulloni&#64;smullyan.org">smulloni&#64;smullyan.org</a>&gt;</td></tr>
<tr><th class="docinfo-name">Revision:</th>
<td>1695</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>2005-11-17 14:43:33 -0500 (Thu, 17 Nov 2005)</td></tr>
<tr><th class="docinfo-name">Status:</th>
<td>Draft</td></tr>
</tbody>
</table>
<div class="contents topic">
<p class="topic-title first"><a id="table-of-contents" name="table-of-contents">Table of Contents</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#introduction" id="id1" name="id1">1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference" href="#acknowledgements" id="id2" name="id2">2&nbsp;&nbsp;&nbsp;Acknowledgements</a></li>
<li><a class="reference" href="#overview" id="id3" name="id3">3&nbsp;&nbsp;&nbsp;Overview</a></li>
<li><a class="reference" href="#defining-table-classes" id="id4" name="id4">4&nbsp;&nbsp;&nbsp;Defining Table Classes</a><ul class="auto-toc">
<li><a class="reference" href="#inheritance-semantics" id="id5" name="id5">4.1&nbsp;&nbsp;&nbsp;Inheritance Semantics</a></li>
<li><a class="reference" href="#projections" id="id6" name="id6">4.2&nbsp;&nbsp;&nbsp;Projections</a></li>
</ul>
</li>
<li><a class="reference" href="#making-queries-getsome-and-getunique" id="id7" name="id7">5&nbsp;&nbsp;&nbsp;Making Queries: <tt class="docutils literal"><span class="pre">getSome()</span></tt> and <tt class="docutils literal"><span class="pre">getUnique()</span></tt></a><ul class="auto-toc">
<li><a class="reference" href="#operators" id="id8" name="id8">5.1&nbsp;&nbsp;&nbsp;Operators</a></li>
<li><a class="reference" href="#order-limit-and-offset" id="id9" name="id9">5.2&nbsp;&nbsp;&nbsp;Order, Limit and Offset</a></li>
<li><a class="reference" href="#refreshing-an-instance" id="id10" name="id10">5.3&nbsp;&nbsp;&nbsp;Refreshing An Instance</a></li>
</ul>
</li>
<li><a class="reference" href="#inserts-updates-and-deletes" id="id11" name="id11">6&nbsp;&nbsp;&nbsp;Inserts, Updates, and Deletes</a><ul class="auto-toc">
<li><a class="reference" href="#python-and-sql-data-types" id="id12" name="id12">6.1&nbsp;&nbsp;&nbsp;Python and SQL Data Types</a></li>
</ul>
</li>
<li><a class="reference" href="#joins" id="id13" name="id13">7&nbsp;&nbsp;&nbsp;Joins</a><ul class="auto-toc">
<li><a class="reference" href="#representing-joins-between-tables" id="id14" name="id14">7.1&nbsp;&nbsp;&nbsp;Representing Joins Between Tables</a></li>
<li><a class="reference" href="#getting-data-from-multiple-tables-at-once" id="id15" name="id15">7.2&nbsp;&nbsp;&nbsp;Getting Data From Multiple Tables At Once</a></li>
</ul>
</li>
<li><a class="reference" href="#managing-database-connections" id="id16" name="id16">8&nbsp;&nbsp;&nbsp;Managing Database Connections</a><ul class="auto-toc">
<li><a class="reference" href="#transactions" id="id17" name="id17">8.1&nbsp;&nbsp;&nbsp;Transactions</a></li>
<li><a class="reference" href="#connection-pools" id="id18" name="id18">8.2&nbsp;&nbsp;&nbsp;Connection Pools</a></li>
</ul>
</li>
<li><a class="reference" href="#a-complete-example" id="id19" name="id19">9&nbsp;&nbsp;&nbsp;A Complete Example</a></li>
<li><a class="reference" href="#differences-from-pydo-1" id="id20" name="id20">10&nbsp;&nbsp;&nbsp;Differences From PyDO 1</a></li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id1" id="introduction" name="introduction">1&nbsp;&nbsp;&nbsp;Introduction</a></h1>
<p>PyDO is an ORM (Object-Relational Mapper) database access library for
Python.  This document describes PyDO version 2.0 and later only.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id2" id="acknowledgements" name="acknowledgements">2&nbsp;&nbsp;&nbsp;Acknowledgements</a></h1>
<p>PyDO was originally written by Drew Csillag in 2000, and released
under the GPL license in 2001 as part of SkunkWeb.  Several developers
have contributed to the codebase since then (see ACKNOWLEDGEMENTS in
the source distribution).  Jacob Smullyan is responsible for work on
the 2.0 series, but while errors and misfeatures are attributable to
him, the fundamental design remains Csillag's.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id3" id="overview" name="overview">3&nbsp;&nbsp;&nbsp;Overview</a></h1>
<div class="note">
<p class="first admonition-title">Note</p>
<p>PyDO is a Python package (finally named <tt class="docutils literal"><span class="pre">pydo</span></tt> in 2.0a3
and later; PyDO1 used the package name <tt class="docutils literal"><span class="pre">PyDO</span></tt>, and previous
alpha releases of PyDO2 used first <tt class="docutils literal"><span class="pre">PyDO</span></tt> and then <tt class="docutils literal"><span class="pre">PyDO2</span></tt>),
but all the public objects within its submodules (with the
exception of the drivers) are imported into its top-level
namespace.  In what follows we will assume that the current
namespace has been initialized by:</p>
<pre class="literal-block">
from pydo import *
</pre>
<p class="last">(In particular, this means that when we want to refer to the
<tt class="docutils literal"><span class="pre">pydo.PyDO</span></tt> class, we shall just write <tt class="docutils literal"><span class="pre">PyDO</span></tt>.)</p>
</div>
<p>PyDO's basic strategy is to let you define a <tt class="docutils literal"><span class="pre">PyDO</span></tt> subclass for
every table in a database that you wish to represent.  Each <tt class="docutils literal"><span class="pre">PyDO</span></tt>
instance contains the data for one row in a database table. As
<tt class="docutils literal"><span class="pre">PyDO</span></tt> is a <tt class="docutils literal"><span class="pre">dict</span></tt> subclass, you can access this data by key, and,
if the class attribute <tt class="docutils literal"><span class="pre">use_attributes</span></tt> is true (the default) also
by attribute.  In either case, the key or attribute name is the name
of the database column:</p>
<pre class="literal-block">
&gt;&gt;&gt; MyPyDOInstance.title
'Fustian Wonders'
&gt;&gt;&gt; MyPyDOInstance['title']
'Fustian Wonders'
</pre>
<p>If you have column names that are Python keywords (such as &quot;pass&quot;,
&quot;class&quot;, etc.)  a warning will be raised when the class is defined and
an attempt at attribute access of that field will give rise to a
<tt class="docutils literal"><span class="pre">SyntaxError</span></tt>, but you'll still be able to access it
dictionary-style.</p>
<p>Instances are normally obtained, not by directly invoking the <tt class="docutils literal"><span class="pre">PyDO</span></tt>
class's constructor, but by calling one of various class methods,
discussed below, that return single instances or lists thereof.</p>
<p>PyDO is not an attempt to model all of SQL or its relational model.
Its focus is on modelling those relations that tend to be both
selectable and updateable, namely, tables.  Since PyDO does not
provide a complete abstraction layer over SQL, it is entirely
appropriate for PyDO-generated queries to be mixed with raw SQL
queries in real applications (although that may be hidden in your own
abstraction layer).</p>
<p>PyDO 2 requires Python 2.4 or later.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id4" id="defining-table-classes" name="defining-table-classes">4&nbsp;&nbsp;&nbsp;Defining Table Classes</a></h1>
<p>To model a database table, you define a subclass of <tt class="docutils literal"><span class="pre">PyDO</span></tt> and set
some class attributes that describe the table:</p>
<pre class="literal-block">
from pydo import PyDO, Sequence, Unique

class Article(PyDO):
    &quot;&quot;&quot;PyDO class for the Article table&quot;&quot;&quot;

    # define a connection alias so that PyDO knows how to
    # connect to the database
    connectionAlias='my_db'

    # the schema name, if applicable, e.g.:
    # schema = 'myschema'

    # the table name.
    table='article'

    # whether we are allowed to update instances of this class;
    # this defaults to True anyway.
    mutable=True

    # whether, after creating a new instance (i.e., performing
    # an insert) the instance should be refreshed to get any
    # default (or other automatic) values.
    refetch=True

    # declare the fields
    fields=(Sequence('id'),
            Unique('title'),
            'slug',
            'author',
            'created',
            'body')
</pre>
<p>The <tt class="docutils literal"><span class="pre">connectionAlias</span></tt> attribute must correspond to an alias
initialized elsewhere (with the <tt class="docutils literal"><span class="pre">initAlias()</span></tt> function) that tells
PyDO how to create a database connection.</p>
<p>If the database supports schemas, like later versions of PostgreSQL,
the schema name can be specified by setting the <tt class="docutils literal"><span class="pre">schema</span></tt> attribute.
When PyDO then generates SQL referring to this table, it will qualify
it with the schema name.  By default, <tt class="docutils literal"><span class="pre">schema</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt> and there
will be no such qualification.  (The method that returns the actual
qualified tablename is <tt class="docutils literal"><span class="pre">getTable(cls,</span> <span class="pre">withSchema=True)</span></tt>; the
<tt class="docutils literal"><span class="pre">withSchema</span></tt> parameter determines whether the returned value is
schema qualified.)</p>
<p>The <tt class="docutils literal"><span class="pre">table</span></tt> attribute is simply the name of the table, view, or
table-like entity (set function, for instance).  By default, you can
leave this out if the name of the class is the name of the table; in
this case, <tt class="docutils literal"><span class="pre">cls.table</span></tt> will be a name made by coercing the class
name to lowercase.  If you don't want to allow this behavior, you can
suppress it by setting the class attribute <tt class="docutils literal"><span class="pre">guess_tablename</span></tt> to
<tt class="docutils literal"><span class="pre">False</span></tt>.  (Note that this feature is of limited utility for database
systems like mysql whose table/column names may be case-sensitive.)</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">If you declare the table explicitly in a class, the
<tt class="docutils literal"><span class="pre">guess_tablename</span></tt> attribute is set to <tt class="docutils literal"><span class="pre">False</span></tt> (unless you
simultaneously set it also) so that subclasses will
inherit the declared table name.</p>
</div>
<p>The <tt class="docutils literal"><span class="pre">fields</span></tt> attribute should be a tuple or list of either <tt class="docutils literal"><span class="pre">Field</span></tt>
instances (of which <tt class="docutils literal"><span class="pre">Sequence</span></tt> and <tt class="docutils literal"><span class="pre">Unique</span></tt> are subclasses), or
data -- strings (which should be column names), dicts, or tuples --
that can be passed to a <tt class="docutils literal"><span class="pre">Field</span></tt> constructor (e.g.,
<tt class="docutils literal"><span class="pre">Field(*fieldTuple)</span></tt>).  You can use your own <tt class="docutils literal"><span class="pre">Field</span></tt> subclasses if
you wish to store additional information about fields (e.g., data
type, validators, etc.), and if you want to customize how strings,
tuples, or dicts are turned into <tt class="docutils literal"><span class="pre">Fields</span></tt> for you, you can shadow
the static factory method <tt class="docutils literal"><span class="pre">PyDO.create_field()</span></tt> to do so.</p>
<p>A <tt class="docutils literal"><span class="pre">Sequence</span></tt> field is used to represent either an auto-increment
column, for databases like MySQL that use that mechanism, or a
sequence column, as used in PostgreSQL.  These columns are implicitly
unique and not null.  For PostgreSQL, you can explicitly declare the
name of the sequence with the <tt class="docutils literal"><span class="pre">sequence</span></tt> parameter of the
<tt class="docutils literal"><span class="pre">Sequence</span></tt> constructor:</p>
<pre class="literal-block">
Sequence('id', 'chimpanzee_id_seq')
</pre>
<p>If you do not, PyDO will infer the name of the sequence from the name
of the table and field, i.e.:</p>
<pre class="literal-block">
$table_$field_seq
</pre>
<p>A <tt class="docutils literal"><span class="pre">Unique</span></tt> field is used to represent a column that has a
single-column uniqueness constraint and is not null.  Multiple-column
not-null uniqueness constraints can also be indicated, with the
<tt class="docutils literal"><span class="pre">unique</span></tt> class attribute:</p>
<pre class="literal-block">
from pydo import PyDO

class ArticleKeywordJunction(PyDO):
&quot;&quot;&quot;PyDO class for junction table between Article and Keyword&quot;&quot;&quot;
    connectionAlias=&quot;my_db&quot;
    table=&quot;article_keyword_junction&quot;
    fields=('article_id',
            'keyword_id')
    unique=(('article_id', 'keyword_id'),)
</pre>
<p>The <tt class="docutils literal"><span class="pre">unique</span></tt> attribute can be thought of as analogous to how, in
SQL, you may declare uniqueness constraints in a separate clause after
you have declared the fields; it is optional to do so for
single-column uniqueness constraints, which are more conveniently
declared inline with the field, but necessary for the multi-column
case.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">The reason that in PyDO, declaring a uniqueness constraint
implies a not null constraint, is that PyDO is only interested in
unique constraints as a way of determining precisely to which row
in the database a given object corresponds.  A nullable uniqueness
constraint is of no use to PyDO in this regard, and hence the
library doesn't attempt to model it.</p>
</div>
<p>It is not necessary to declare any uniqueness constraints in a
<tt class="docutils literal"><span class="pre">PyDO</span></tt> class at all, either implicitly with the <tt class="docutils literal"><span class="pre">Unique</span></tt> field
class, or via the <tt class="docutils literal"><span class="pre">unique</span></tt> class attribute.  However, if you do not,
instances of the corresponding <tt class="docutils literal"><span class="pre">PyDO</span></tt> class won't be able to
identify the unique rows in the database table to which they
correspond, and hence the instances will not be mutable.  (If the
class is mutable, however, it will still be possible to perform
inserts and mass updates and deletes.)</p>
<p>The inherited fields, uniqueness constraints, and sequences of a class
may be read, but not changed, through the class methods
<tt class="docutils literal"><span class="pre">getFields()</span></tt>, <tt class="docutils literal"><span class="pre">getUniquenessConstraints()</span></tt>, and
<tt class="docutils literal"><span class="pre">getSequences()</span></tt>, respectively.</p>
<p>If you omit the <tt class="docutils literal"><span class="pre">fields</span></tt> and <tt class="docutils literal"><span class="pre">unique</span></tt> declarations completely and
declare the class attribute <tt class="docutils literal"><span class="pre">guess_columns</span></tt>, PyDO will attempt to
introspect into the database and build the table description itself at
class creation time.  The declaration only affects the class in which
it is declared; classes that inherit the attribute will not themselves
attempt to guess columns.  By default, column guessing will require
querying the database when the class is initialized for every process
in which the class is imported; to mitigate this potential performance
hit, the data can be cached to disk if you set <tt class="docutils literal"><span class="pre">PyDO.guesscache</span></tt> to
an instance of <tt class="docutils literal"><span class="pre">GuessCache</span></tt> or a compatible object, or to <tt class="docutils literal"><span class="pre">1</span></tt> or
<tt class="docutils literal"><span class="pre">True</span></tt>, in which case a default <tt class="docutils literal"><span class="pre">GuessCache</span></tt> will be used.
<tt class="docutils literal"><span class="pre">GuessCache</span></tt> stores pickles associated with classes in a cache
directory, by default one created with the name
<tt class="docutils literal"><span class="pre">$USERNAME_pydoguesscache</span></tt> inside <tt class="docutils literal"><span class="pre">tempfile.gettempdir()</span></tt>, where
<tt class="docutils literal"><span class="pre">$USERNAME</span></tt> is the login of the current user; if the schema of one
of your objects has changed and you want to refresh the cache, simply
delete the corresponding cache object and restart your application.</p>
<p>Finally, if you are writing a quick script and want basic,
uncustomized PyDO classes for every table in a schema, the function
<tt class="docutils literal"><span class="pre">autoschema</span></tt> will generate them for you, and return them to you
in a dictionary keyed by class name:</p>
<pre class="literal-block">
globals().update(autoschema(alias='myDBAlias',
                            schema='public',
                            guesscache=True,
                            module=someModule)
</pre>
<p>By default, it will use the default <tt class="docutils literal"><span class="pre">GuessCache</span></tt>, and specify no
schema; you must give an alias (which should be initialized first with
<tt class="docutils literal"><span class="pre">initAlias</span></tt>).  The <tt class="docutils literal"><span class="pre">module</span></tt> parameter has the same effect as the
<tt class="docutils literal"><span class="pre">module</span></tt> parameter to <tt class="docutils literal"><span class="pre">PyDO.project()</span></tt>: it causes the new classes
to be associated with the provided module, so they can be pickled and
unpickled.  While convenient for scripts, using <tt class="docutils literal"><span class="pre">autoschema</span></tt> gives
you no way of adding methods to your PyDO objects or customizing their
attributes, so isn't well suited for PyDO's main purpose, namely,
crafting an application's data access layer.</p>
<div class="section">
<h2><a class="toc-backref" href="#id5" id="inheritance-semantics" name="inheritance-semantics">4.1&nbsp;&nbsp;&nbsp;Inheritance Semantics</a></h2>
<p><tt class="docutils literal"><span class="pre">PyDO</span></tt> classes are normal Python classes (subclassing <tt class="docutils literal"><span class="pre">dict</span></tt>)
which use a metaclass to parse the <tt class="docutils literal"><span class="pre">field</span></tt> and <tt class="docutils literal"><span class="pre">unique</span></tt> class
attribute declarations and store the derived information in private
fields.  Special inheritance semantics obtain for <tt class="docutils literal"><span class="pre">field</span></tt> and
<tt class="docutils literal"><span class="pre">unique</span></tt>, in that the privately stored parsed values corresponding
to those declarations are inherited from superclasses even if
<tt class="docutils literal"><span class="pre">fields</span></tt> is redeclared in the subclass, shadowing any superclass's
declaration.  Subclasses therefore may augment the field listing of
their base classes.  This behavior is applicable not only to cases
like PostgreSQL table inheritance, but to defining base or mixin
classes (which need not be <tt class="docutils literal"><span class="pre">PyDO</span></tt> subclasses themselves) that define
groups of fields that are shared by multiple tables.</p>
<p>Normally, if a subclasses redeclares a field declared by a base class,
the subclass's declaration overrides that of the base class, but an
exception is made for declarations that simply state the fieldname as
a string; in that case, any previous, more informative declaration
will be inherited.</p>
<div class="warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is generally useful (in the case of projections particularly
--see below) but if you wished to override a superclass's
definition, say, of <tt class="docutils literal"><span class="pre">Unique('species')</span></tt>, just to the non-unique
<tt class="docutils literal"><span class="pre">Field('species')</span></tt>, you would have to explicitly use the
<tt class="docutils literal"><span class="pre">Field</span></tt> constructor rather than simply <tt class="docutils literal"><span class="pre">'species'</span></tt>.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id6" id="projections" name="projections">4.2&nbsp;&nbsp;&nbsp;Projections</a></h2>
<p>An exception is made to the default inheritance behavior -- that
subclasses augment, rather than shadow, their superclasses' field
listing -- for the case of projection subclasses, in which the local
declaration of fields overrides that of superclasses.  Projections are
useful when you wish to select only a few columns from a larger table.
To derive a projection from a <tt class="docutils literal"><span class="pre">PyDO</span></tt> class, simply call the class
method <tt class="docutils literal"><span class="pre">project()</span></tt> on the class, passing in a tuple of fields as
positional arguments (or as a single tuple/list) that you wish to
include in the projection:</p>
<pre class="literal-block">
myProjection=MyBaseClass.project('id', 'title')
</pre>
<p>The <tt class="docutils literal"><span class="pre">project()</span></tt> method also accepts two keyword arguments:
<tt class="docutils literal"><span class="pre">mutable</span></tt> and <tt class="docutils literal"><span class="pre">module</span></tt>, which if provided will respectively
override the <tt class="docutils literal"><span class="pre">mutable</span></tt> attribute of the base class, and cause the
projection to be stored in the namespace of the provided module, also
setting the <tt class="docutils literal"><span class="pre">__module__</span></tt> attribute of the new class so that it can
pickled and unpickled.</p>
<p>The return value is a subclass of <tt class="docutils literal"><span class="pre">myBaseClass</span></tt> with the fields
<tt class="docutils literal"><span class="pre">id</span></tt> and <tt class="docutils literal"><span class="pre">title</span></tt>. This class is cached, so if you call
<tt class="docutils literal"><span class="pre">project()</span></tt> again with the same arguments you'll get a reference to
the same class.</p>
<p>Because of the special inheritance semantics for simple string field
declarations, if <tt class="docutils literal"><span class="pre">MyBaseClass</span></tt> in the above example is defined as
follows:</p>
<pre class="literal-block">
class myBaseClass(PyDO):
    fields=(Sequenced('id'),
            Unique('title'),
            'author'
            'ISBN',
            'first_chapter')
</pre>
<p><tt class="docutils literal"><span class="pre">myProjection</span></tt> will still know that <tt class="docutils literal"><span class="pre">id</span></tt> and <tt class="docutils literal"><span class="pre">title</span></tt> are unique,
and that <tt class="docutils literal"><span class="pre">id</span></tt> is sequenced.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id7" id="making-queries-getsome-and-getunique" name="making-queries-getsome-and-getunique">5&nbsp;&nbsp;&nbsp;Making Queries: <tt class="docutils literal"><span class="pre">getSome()</span></tt> and <tt class="docutils literal"><span class="pre">getUnique()</span></tt></a></h1>
<p>There are two class methods provided for performing SELECTs.
<tt class="docutils literal"><span class="pre">getSome</span></tt> returns a list of rows of <tt class="docutils literal"><span class="pre">PyDO</span></tt> instances:</p>
<pre class="literal-block">
 &gt;&gt;&gt; myFungi.getSome()
[{'id' : 1, 'species' : 'Agaricus lilaceps', 'comment' : 'nice shroom!'},
 {'id' : 2, 'species' :  'Agaricus micromegathus', 'comment' : ''}]
</pre>
<p><tt class="docutils literal"><span class="pre">getUnique</span></tt> returns a single instance.  You must provide enough
information to <tt class="docutils literal"><span class="pre">getUnique</span></tt> to satisfy one declared uniqueness
constraint; this is accomplished by passing in keyword parameters
where the keywords are column names corresponding to the columns of a
uniqueness constraint declared for the object, and the values are what
you are asserting those columns equal for the unique row:</p>
<pre class="literal-block">
&gt;&gt;&gt; myFungi.getUnique(id=2)
{'id' : 2, 'species' :  'Agaricus micromegathus', 'comment' : ''}
&gt;&gt;&gt; myFungi.getUnique(id=55) is None
True
</pre>
<p><tt class="docutils literal"><span class="pre">getSome</span></tt> is similar, but admits a much wider range of query
options, and returns a list of <tt class="docutils literal"><span class="pre">PyDO</span></tt> instances.  Assuming that
<tt class="docutils literal"><span class="pre">comment</span></tt> is not a unique field above, you could not add selection
criteria based on <tt class="docutils literal"><span class="pre">comment</span></tt> to <tt class="docutils literal"><span class="pre">getUnique()</span></tt>, but could to
<tt class="docutils literal"><span class="pre">getSome</span></tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; myFungi.getSome(comment=None)
[{'id' : 2, 'species' :  'Agaricus micromegathus', 'comment' :  ''}]
&gt;&gt;&gt; myFungi.getSome(comment='better than asparagus', id=55)
[]
</pre>
<div class="section">
<h2><a class="toc-backref" href="#id8" id="operators" name="operators">5.1&nbsp;&nbsp;&nbsp;Operators</a></h2>
<p>In addition to specifying selection criteria by keyword argument, PyDO
gives you three other ways:</p>
<ol class="arabic">
<li><p class="first">If you supply a string as the first argument to <tt class="docutils literal"><span class="pre">getSome()</span></tt>, it
will be placed as-is in a WHERE clause.  Remaining positional
arguments will be taken to be values for bind variables in the
string:</p>
<pre class="literal-block">
&gt;&gt;&gt; myFungi.getSome(&quot;comment != %s&quot;, 'favorite of frogs')
</pre>
<p>If you use bind variables, the paramstyle you use must be the
same as that of the underlying Python DBAPI driver.  To support
the <tt class="docutils literal"><span class="pre">pyformat</span></tt> and <tt class="docutils literal"><span class="pre">named</span></tt> paramstyles, in which variables
are passed in a dictionary, you can pass in a dictionary as the
second argument.  When using this style with <tt class="docutils literal"><span class="pre">getSome()</span></tt>, you
cannot use keyword arguments to express column equivalence.</p>
</li>
<li><p class="first">You can use <tt class="docutils literal"><span class="pre">SQLOperator</span></tt> instances:</p>
<pre class="literal-block">
&gt;&gt;&gt; myFungi.getSome(OR(EQ(FIELD('comment'), 'has pincers'),
...                    LT(FIELD('id'), 40),
...                    LIKE(FIELD('species'), '%micromega%')))
[{'id' : 2, 'species' :  'Agaricus micromegathus', 'comment' :  ''}]
</pre>
</li>
<li><p class="first">You can use tuples that are turned into <tt class="docutils literal"><span class="pre">SQLOperator</span></tt> instances
for you; this is equivalent to the above:</p>
<pre class="literal-block">
&gt;&gt;&gt; myFungi.getSome(('OR',
...                  ('=', FIELD('comment'), 'has pincers'),
...                  ('&lt;', FIELD('id'), 40),
...                  ('LIKE', FIELD('species', '%micromega%'))))
[{'id' : 2, 'species' :  'Agaricus micromegathus', 'comment' :  ''}]
</pre>
</li>
</ol>
<p>Either operator syntax can be mixed freely with each other and with
keyword arguments to express column equivalence.</p>
<p>The basic idea of operators is that they renotate SQL in a prefix
rather than infix syntax, which may not be to everyone's taste; you
don't need to use them, as they are purely syntactical sugar.  One
convenient thing about them is that they automatically convert values
included in them to bind variables in the style of the underlying
DBAPI driver.</p>
<p>To represent an unquoted value, like a fieldname, a constant, or a
function, use the <tt class="docutils literal"><span class="pre">FIELD</span></tt> or <tt class="docutils literal"><span class="pre">CONSTANT</span></tt> classes (actually, they
are synonyms).  Another helper class is <tt class="docutils literal"><span class="pre">SET</span></tt>, for use with the
<tt class="docutils literal"><span class="pre">IN</span></tt> operator:</p>
<pre class="literal-block">
&gt;&gt;&gt; myFungi.getSome(IN(FIELD('comment'),
...                    SET('nice shroom!', 'has pincers')))
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id9" id="order-limit-and-offset" name="order-limit-and-offset">5.2&nbsp;&nbsp;&nbsp;Order, Limit and Offset</a></h2>
<p><tt class="docutils literal"><span class="pre">getSome()</span></tt> accepts three additional keyword arguments:</p>
<blockquote>
<dl class="docutils">
<dt>order</dt>
<dd>a fieldname to order by, with optional ' ASC' or ' DESC'
suffix, or a tuple of such fieldname-with-optional-suffix
strings.</dd>
<dt>offset</dt>
<dd>an integer</dd>
<dt>limit</dt>
<dd>an integer</dd>
</dl>
</blockquote>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id10" id="refreshing-an-instance" name="refreshing-an-instance">5.3&nbsp;&nbsp;&nbsp;Refreshing An Instance</a></h2>
<p>If you have reason to believe that the data you have for an object is
inaccurate or out of date, you can refresh it by calling
<tt class="docutils literal"><span class="pre">myObj.refresh()</span></tt>, as long as the object has uniqueness constraints
so it is possible to get the unique row to which it corresponds.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id11" id="inserts-updates-and-deletes" name="inserts-updates-and-deletes">6&nbsp;&nbsp;&nbsp;Inserts, Updates, and Deletes</a></h1>
<p>To insert a new record in the database and create the corresponding
<tt class="docutils literal"><span class="pre">PyDO</span></tt> object, use the class method <tt class="docutils literal"><span class="pre">new()</span></tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; subscription=Subscriptions.new(email='alvin&#64;krinst.org',
                                   magazine='NYRB')
&gt;&gt;&gt; subscription
{'email' : 'alvin&#64;krinst.org', 'magazine' : 'NYRB'}
</pre>
<p>If the object has a field which will acquire a default non-null value
even though you haven't specified a value for it, PyDO will
automatically refetch it for you if you have set <tt class="docutils literal"><span class="pre">cls.refetch</span></tt> to a
true value:</p>
<pre class="literal-block">
&gt;&gt;&gt; Sonnet.refetch
True
&gt;&gt;&gt; poem=Sonnet.new(title='Anguished Parsnips',
                    body='\n'.join(' '.join(['oy veh!' * 5]) * 14))
&gt;&gt;&gt; poem.created
datetime.datetime(2005, 5, 9, 11, 6, 25, 221004)
</pre>
<p>This is equivalent to calling <tt class="docutils literal"><span class="pre">refresh()</span></tt> after <tt class="docutils literal"><span class="pre">new()</span></tt>, and also
requires that a uniqueness constraint be been declared for the class.
You can also explicitly set the refetch behavior on a per-call basis
by using the methods <tt class="docutils literal"><span class="pre">newfetch()</span></tt> and <tt class="docutils literal"><span class="pre">newnofetch()</span></tt>, or (for
backwards compatibility with PyDO1) by using a deprecated keyword
parameter, <tt class="docutils literal"><span class="pre">refetch</span></tt>, to <tt class="docutils literal"><span class="pre">new()</span></tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; dud=Failure.newfetch(name=&quot;Charlie Brown&quot;)
&gt;&gt;&gt; dud2=Failure.new(refetch=1, name=&quot;Oblomov&quot;)
</pre>
<p>Usually this isn't necessary, as whether you need to refetch is
primarily determined by the characteristics of the table, but
sometimes it useful -- for instance, if refetch is true class-wide,
but you don't plan on doing anything with the object you are
creating, it will be more efficient to use <tt class="docutils literal"><span class="pre">newnofetch</span></tt>.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">The <tt class="docutils literal"><span class="pre">refetch</span></tt> parameter to <tt class="docutils literal"><span class="pre">new()</span></tt> is deprecated because
it makes it awkward to have a column named <tt class="docutils literal"><span class="pre">refetch</span></tt>.  In PyDO2,
if you have a field named &quot;refetch&quot;, the <tt class="docutils literal"><span class="pre">refetch</span></tt> keyword
argument to <tt class="docutils literal"><span class="pre">new()</span></tt> will be interpreted as field data and won't
affect refetch behavior.</p>
</div>
<p>If you don't specify the value of a column when calling <tt class="docutils literal"><span class="pre">new()</span></tt>, and
there is no refetch, PyDO will assume that the default value is null
and store <tt class="docutils literal"><span class="pre">None</span></tt> for that column.</p>
<p>If a class is declared mutable and has a uniqueness constraint, it is
possible to mutate an undeleted instance of it by calling:</p>
<pre class="literal-block">
&gt;&gt;&gt; poem['title']='Sayings of the Robo-Rabbi'
</pre>
<p>or, equivalently, if <tt class="docutils literal"><span class="pre">use_attributes</span></tt> is true for the class:</p>
<pre class="literal-block">
&gt;&gt;&gt; poem.title='Sayings of the Robo-Rabbi'
</pre>
<p>Multiple updates can be done together via <tt class="docutils literal"><span class="pre">update()</span></tt>:</p>
<pre class="literal-block">
MyInstance.update(dict(fieldname=newValue,
                       otherFieldname=otherValue))
</pre>
<p>Each mutation will cause an UPDATE statement to be executed on the
underlying database. If you attempt to mutate an immutable <tt class="docutils literal"><span class="pre">PyDO</span></tt>
instance, a <tt class="docutils literal"><span class="pre">PyDOError</span></tt> will be raised.  A <tt class="docutils literal"><span class="pre">PyDOError</span></tt> will also
be raised if the number of rows affected, as returned by the database
driver, is not equal to 1.  If the driver returns something other than
1 for a successful update in a particular case (for instance, for an
updateable view), set the class attribute <tt class="docutils literal"><span class="pre">_ignore_update_rowcount</span></tt>
to <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<p>It is also possible to update potentially many rows at once with the
class method <tt class="docutils literal"><span class="pre">updateSome()</span></tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; Article.updateSome(dict(slug=&quot;nonsense&quot;),
...                    LT(FIELD(&quot;created&quot;),
...                       CONSTANT(&quot;CURRENT_TIMESTAMP&quot;)),
...                    author='Smullyan')
6
</pre>
<p>The first argument to <tt class="docutils literal"><span class="pre">updateSome()</span></tt> is a dictionary of values to
set for affected rows; remains positional and keyword args accept the
same arguments as <tt class="docutils literal"><span class="pre">getSome()</span></tt> (with the exception of <tt class="docutils literal"><span class="pre">order</span></tt>,
<tt class="docutils literal"><span class="pre">limit</span></tt>, and <tt class="docutils literal"><span class="pre">offset</span></tt> which wouldn't make sense in this context).
The return value is the number of affected rows.</p>
<p>To delete an instance, call the instance method <tt class="docutils literal"><span class="pre">delete()</span></tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; Article.getUnique(id=44).delete()
</pre>
<p>The method returns nothing; the instance in question is marked as
immutable.</p>
<p>To delete many rows at once, use the class method <tt class="docutils literal"><span class="pre">deleteSome()</span></tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; Article.deleteSome(LT(FIELD(&quot;created&quot;),
...                       CONSTANT(&quot;CURRENT_TIMESTAMP&quot;)),
...                    author=&quot;Grisby Holloway&quot;)
</pre>
<p>The parameters accepted are again the same as for <tt class="docutils literal"><span class="pre">getSome())</span></tt>,
except for <tt class="docutils literal"><span class="pre">order</span></tt>, <tt class="docutils literal"><span class="pre">limit</span></tt>, and <tt class="docutils literal"><span class="pre">offset</span></tt>, and the return value
is the number of affected rows.</p>
<div class="section">
<h2><a class="toc-backref" href="#id12" id="python-and-sql-data-types" name="python-and-sql-data-types">6.1&nbsp;&nbsp;&nbsp;Python and SQL Data Types</a></h2>
<p>The marshalling of SQL datatypes into Python is entirely left to the
DBAPI drivers which underlie PyDO.  Ideally, the reverse would also be
true, but PyDO drivers are able to perform some conversion where the
DBAPI drivers fail to (e.g., this is necessary to handle
<tt class="docutils literal"><span class="pre">mx.DateTime</span></tt> in the <tt class="docutils literal"><span class="pre">psycopg</span></tt> driver when using <tt class="docutils literal"><span class="pre">psycopg1</span></tt>).
PyDO also includes some typewrapper classes -- <tt class="docutils literal"><span class="pre">DATE</span></tt>,
<tt class="docutils literal"><span class="pre">TIMESTAMP</span></tt>, <tt class="docutils literal"><span class="pre">BINARY</span></tt>, and <tt class="docutils literal"><span class="pre">INTERVAL</span></tt> -- which can be used for
updates to coerce data to the appropriate SQL type.  The main feature
of these wrapper classes is that PyDO knows how to unwrap them, so
that after an update the column in question will contain the wrapped
value, not the wrapper instance itself.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id13" id="joins" name="joins">7&nbsp;&nbsp;&nbsp;Joins</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id14" id="representing-joins-between-tables" name="representing-joins-between-tables">7.1&nbsp;&nbsp;&nbsp;Representing Joins Between Tables</a></h2>
<p>To represent a one-to-one join between classes <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt>, you
might add instance methods to class <tt class="docutils literal"><span class="pre">A</span></tt>, e.g.:</p>
<pre class="literal-block">
def getB(self):
    return B.getUnique(id=self.b_id)

def setB(self, item):
    if item is None:
        self.b_id=None
    else:
        self.b_id=item.id

B=property(getB, setB)
</pre>
<p>PyDO provides an equivalent shortcut:</p>
<pre class="literal-block">
B=ForeignKey('b_id', 'id', B)
</pre>
<p>If the class <tt class="docutils literal"><span class="pre">B</span></tt> hasn't been defined yet, but will be defined later
in the same module, you can use its name as a string:</p>
<pre class="literal-block">
B=ForeignKey('b_id', 'id', 'B')
</pre>
<p>And if it is defined in a different module, you can give its fully
qualified name:</p>
<pre class="literal-block">
B=ForeignKey('b_id', 'id', 'somePackage.someModule.B')
</pre>
<p>When using a string, the actual class is looked up at runtime.</p>
<p>Similarly, to represent a one-to-many join, you could write your own
accessor method, calling <tt class="docutils literal"><span class="pre">B.getSome()</span></tt>:</p>
<pre class="literal-block">
def getBs(self, *args, **kwargs):
    return B.getSome(a_id=self.id, *args, **kwargs)
</pre>
<p>Again, PyDO provides a terser alternative:</p>
<pre class="literal-block">
getBs=OneToMany('id', 'a_id', B)
</pre>
<p>The result is the same -- <tt class="docutils literal"><span class="pre">getBs</span></tt> will be an instance method that
takes positional and keyword arguments like <tt class="docutils literal"><span class="pre">getSome()</span></tt>.  Again,
<tt class="docutils literal"><span class="pre">B</span></tt> can be either a class or a string representing that class.</p>
<p>To represent a many-to-many join between <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt> through
junction table <tt class="docutils literal"><span class="pre">J</span></tt>, you either add an instance method that calls
<tt class="docutils literal"><span class="pre">joinTable()</span></tt>:</p>
<pre class="literal-block">
def getBs(self, *args, **kwargs):
    return self.joinTable('id', 'J', 'a_id', 'b_id',
                          B, 'id', *args, **kwargs)
</pre>
<p>or again use an equivalent shortcut, which is:</p>
<pre class="literal-block">
getBs=ManyToMany('id', 'J', 'a_id', 'b_id', B, 'id')
</pre>
<p><tt class="docutils literal"><span class="pre">joinTable()</span></tt> takes the following arguments:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">thisAttrNames</span></tt></dt>
<dd>attribute(s) in current object to join from</dd>
<dt><tt class="docutils literal"><span class="pre">pivotTable</span></tt></dt>
<dd>pivot table name</dd>
<dt><tt class="docutils literal"><span class="pre">thisSideColumns</span></tt></dt>
<dd>column(s) that correspond to the foreign key column to <tt class="docutils literal"><span class="pre">thisAttrNames</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">thatSideColumns</span></tt></dt>
<dd>column(s) that correspond to the foreign key column to <tt class="docutils literal"><span class="pre">thatAttrNames</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">thatObject</span></tt></dt>
<dd>the destination object (or its class name)</dd>
<dt><tt class="docutils literal"><span class="pre">thatAttrNames</span></tt></dt>
<dd>attribute(s) in destination object to join to</dd>
</dl>
<p>In addition, <tt class="docutils literal"><span class="pre">joinTable()</span></tt> takes positional and keyword arguments,
similar to <tt class="docutils literal"><span class="pre">getSome()</span></tt>; it will accept raw SQL and bind values or
<tt class="docutils literal"><span class="pre">SQLOperator</span></tt> instances as positional arguments, and understands the
keyword arguments <tt class="docutils literal"><span class="pre">order</span></tt>, <tt class="docutils literal"><span class="pre">limit</span></tt>, and <tt class="docutils literal"><span class="pre">offset</span></tt> as well as
column name keyword arguments.  Also, if you wish to pass in
additional tables to the select, you can do so with the
<tt class="docutils literal"><span class="pre">extraTables</span></tt> keyword argument, with which you can pass a single
table name, or a list of names.</p>
<p><tt class="docutils literal"><span class="pre">ManyToMany</span></tt> takes the same arguments as <tt class="docutils literal"><span class="pre">joinTable</span></tt> in the same
order, except for the optional positional and keyword arguments, which
can be passed when the bound method that results from using
<tt class="docutils literal"><span class="pre">ManyToMany</span></tt> is called.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id15" id="getting-data-from-multiple-tables-at-once" name="getting-data-from-multiple-tables-at-once">7.2&nbsp;&nbsp;&nbsp;Getting Data From Multiple Tables At Once</a></h2>
<p>The <tt class="docutils literal"><span class="pre">fetch</span></tt> function makes it possible to query multiple tables, use
aggregates and obtain other non-table data, while still returning
table data coalesced into <tt class="docutils literal"><span class="pre">PyDO</span></tt> instances.  Its signature is:</p>
<pre class="literal-block">
def fetch(resultSpec, sqlTemplate, *values, **kwargs)
</pre>
<p><tt class="docutils literal"><span class="pre">resultSpec</span></tt>, a result set specification, is a list that may
contain:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">PyDO</span></tt> classes;</li>
<li>2-tuples of (<tt class="docutils literal"><span class="pre">PyDO</span></tt> class, alias string), which indicate that the
table represented by the <tt class="docutils literal"><span class="pre">PyDO</span></tt> class is to be referenced in SQL
by the given alias;</li>
<li>strings, which represent arbitrary SQL expressions that may occur in
a SQL column-list specification.</li>
</ul>
<p><tt class="docutils literal"><span class="pre">sqlTemplate</span></tt> is a string that may contain interpolation variables
in the style of <tt class="docutils literal"><span class="pre">string.Template</span></tt>.  In particular, two variables are
supplied to this template automatically:</p>
<blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">$COLUMNS</span></tt></dt>
<dd>a list of columns computed from the supplied resultSpec;</dd>
<dt><tt class="docutils literal"><span class="pre">$TABLES</span></tt></dt>
<dd>a list of tables similarly computed.</dd>
</dl>
</blockquote>
<p>Additional interpolation variables may be passed in as keyword
arguments.  Bind variables to the SQL may also be passed in, through
positional arguments; if there is only one positional argument, and it
is a dictionary, it will be used instead of a list of values, under
the assumption that either the <tt class="docutils literal"><span class="pre">pyformat</span></tt> or <tt class="docutils literal"><span class="pre">named</span></tt> paramstyle is
being used.</p>
<p>For each element <em>E</em> in the resultSpec, the result row contains one
element <em>F</em>.  If <em>E</em> is a <tt class="docutils literal"><span class="pre">PyDO</span></tt> class, <em>F</em> will either be an
instance of <em>E</em>, or, if all its corresponding columns were null for
that row and <em>E</em> has a uniqueness constraint (which in PyDO is
implicitly a not null constraint), <tt class="docutils literal"><span class="pre">None</span></tt>.  If <em>E</em> is a string, <em>F</em>
will be whatever the cursor returned for that column.</p>
<p>For example:</p>
<pre class="literal-block">
&gt;&gt;&gt; tmpl='''SELECT $COLUMNS FROM $TABLES WHERE art.creator=auth.id
...         AND art.id=%s'''
&gt;&gt;&gt; res=fetch([(Article.project('title'), 'art'),
...            (Author.project('lastname'), 'auth'),
...            '3-2'], tmpl, 4)
(({'title': 'My Woodchuck Smarts'}, {'lastname' : 'Pydong'}, 1),)
</pre>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id16" id="managing-database-connections" name="managing-database-connections">8&nbsp;&nbsp;&nbsp;Managing Database Connections</a></h1>
<p>All that a <tt class="docutils literal"><span class="pre">PyDO</span></tt> class knows about its database connection is its
<tt class="docutils literal"><span class="pre">connectionAlias</span></tt> attribute.  Before you use the class, you must
call <tt class="docutils literal"><span class="pre">initAlias()</span></tt> to associate that alias with the data needed to
make an actual database connection:</p>
<pre class="literal-block">
initAlias(alias, driver, connectArgs, pool=False, verbose=False)
</pre>
<p><tt class="docutils literal"><span class="pre">driver</span></tt> must be the name of a driver registered with PyDO; the
built-in ones are currently &quot;mysql&quot;, &quot;psycopg&quot;, &quot;sqlite&quot;, &quot;mssql&quot;, and
&quot;oracle&quot;.  <tt class="docutils literal"><span class="pre">connectArgs</span></tt> are arguments to pass to the underlying
DBAPI driver's <tt class="docutils literal"><span class="pre">connect()</span></tt> function; you can pass a tuple of
positional args, a dictionary of keyword args, or a single object that
will be treated like a tuple of length 1. <tt class="docutils literal"><span class="pre">pool</span></tt> is an optional
connection pool; if you want one, you can either pass a
<tt class="docutils literal"><span class="pre">ConnectionPool</span></tt> instance or something with a compatible
<tt class="docutils literal"><span class="pre">connect()</span></tt> method, or a true value, in which case a default
<tt class="docutils literal"><span class="pre">ConnectionPool</span></tt> will be created.  By default no pool is used.
<tt class="docutils literal"><span class="pre">verbose</span></tt> is whether or not to log the generated SQL; by default no
logging is done.</p>
<p>The class method <tt class="docutils literal"><span class="pre">PyDO.getDBI()</span></tt> returns a database interface object
(an instance of a driver-specific <tt class="docutils literal"><span class="pre">pydo.dbi.DBIBase</span></tt> subclass),
which in turn uses an underlying DBAPI database connection.  The DBAPI
connection is stored in thread-local storage and created lazily when
an attempt is made to access it, so transactions in different threads
will transparently use different connections.  By default the
connection will live as long as the current thread.  If you use a
pool, every time a transaction is completed, the connection will be
released by the DBI object and returned to the pool.  If you aren't
using a pool and are using multiple threads, when the thread is
finished, its connection will go out of scope and will get closed
during garbage collection.</p>
<p>If you want to manage connections outside of PyDO, you can, by using
the DBI object's <tt class="docutils literal"><span class="pre">swapConnection()</span></tt> method:</p>
<pre class="literal-block">
oldConnection=myDBI.swapConnection(newConnection)
# do something with PyDO
</pre>
<p>Because the connections are stored thread-locally, this is
thread-safe.  Using this technique, one could juggle multiple
transactions in the same process without using multiple threads.</p>
<p>The dbapi module that underlies a given DBI object is available as
<tt class="docutils literal"><span class="pre">DBIobj.dbapiModule</span></tt>; the standard dbapi-mandated exceptions defined
in that module are available in a dictionary, <tt class="docutils literal"><span class="pre">DBIobj.exceptions</span></tt>,
keyed by name.</p>
<div class="section">
<h2><a class="toc-backref" href="#id17" id="transactions" name="transactions">8.1&nbsp;&nbsp;&nbsp;Transactions</a></h2>
<p>The DBI object's <tt class="docutils literal"><span class="pre">autocommit</span></tt> property reports whether the drivers
uses transactions (in which case, its value is false).  By default,
most drivers use transactions (mysql being the outstanding exception).
Some drivers support mutating this property, but as a matter of policy
transactions are the norm for PyDO.</p>
<p>To commit a transaction, call <tt class="docutils literal"><span class="pre">commit()</span></tt> on the DBI object, or,
equivalently, on any PyDO class or instance with the corresponding
connection alias, which is equivalent to calling
<tt class="docutils literal"><span class="pre">obj.getDBI().commit()</span></tt>.  To rollback, call <tt class="docutils literal"><span class="pre">rollback()</span></tt>, again
either on the DBI object or on a PyDO object.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Although you may call <tt class="docutils literal"><span class="pre">commit()</span></tt> or <tt class="docutils literal"><span class="pre">rollback()</span></tt> via a
particular class or instance, that is only for convenience and
implies no particular isolation of the commit or rollback to that
object.  If you create six PyDO objects with the same
connectionAlias and commit or rollback one of them, all are
affected equally.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id18" id="connection-pools" name="connection-pools">8.2&nbsp;&nbsp;&nbsp;Connection Pools</a></h2>
<p>If you are using transactions in multiple threads, a connection pool
can reduce the cost of connecting to the database.  The constructor
has this signature:</p>
<pre class="literal-block">
pool=ConnectionPool(max_poolsize=0,
                    keep_poolsize=1,
                    delay=0.2,
                    retries=10)
</pre>
<p><tt class="docutils literal"><span class="pre">max_poolsize</span></tt> is the maximum number of connections it will permit
you to have in the pool at any one time; if 0, there is no upper
limit. <tt class="docutils literal"><span class="pre">keep_poolsize</span></tt> is the maximum number of connections it will
retain in the pool.  (In other words, the pool may grow up to
<tt class="docutils literal"><span class="pre">max_poolsize</span></tt>, but it will keep getting reduced to
<tt class="docutils literal"><span class="pre">keep_poolsize</span></tt> when connections are released.)  <tt class="docutils literal"><span class="pre">delay</span></tt> is the
number of seconds it will delay if it needs to retry getting a
connection, because the pool has reached its maximum size; <tt class="docutils literal"><span class="pre">retries</span></tt>
is the number of times to retry before giving up and raising a
<tt class="docutils literal"><span class="pre">PyDOError</span></tt>.</p>
<p>When a connection is returned to a pool, any outstanding transaction
is rolled back.  Committing or rolling back also causes connections to
be returned to the pool, so normally nothing special needs to be done
to return it or manage the pool.  If transactions are not being used,
however, you'll need to manually return the connection to the pool by
calling <tt class="docutils literal"><span class="pre">dbiObj.endConnection()</span></tt>.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id19" id="a-complete-example" name="a-complete-example">9&nbsp;&nbsp;&nbsp;A Complete Example</a></h1>
<p>Consider the following toy sqlite database:</p>
<pre class="literal-block">
CREATE TABLE contact (
  id integer not null primary key,
  first_name text,
  last_name text not null,
  address_id1 integer references address,
  address_id2 integer references address,
  email1 text,
  email2 text,
  work_phone text,
  home_phone text,
  mobile_phone text
);

CREATE TABLE address (
  id integer not null primary key,
  line1 text,
  line2 text,
  town text,
  state text,
  country text,
  postal_code text
);

CREATE TABLE note (
  id integer not null primary key,
  title text,
  body text not null,
  created timestamp
);

CREATE TABLE contact_note (
  contact_id integer references contact,
  note_id integer references note,
  primary key (contact_id, note_id)
);
  


</pre>
<p>The following Python module wraps its tables in an api:</p>
<pre class="literal-block">
&quot;&quot;&quot;
a small example PIM application, using sqlite.

The schema is actually rather ridiculous (why are contact -&gt; notes
many to many?)  but you get the idea.

&quot;&quot;&quot;
import os
from mx.DateTime import now
from pydo import *

class Note(PyDO):
    connectionAlias=&quot;pim&quot;
    # if created had a default value (which
    # it would if the version of sqlite this was
    # tested on supported anything like CURRENT_TIMESTAMP)
    # I'd set:
    # refetch=True
    fields=(Sequence('id'),
            'title',
            'body',
            'created')

class Address(PyDO):
    connectionAlias='pim'
    fields=(Sequence('id'),
            'line1',
            'line2',
            'town',
            'state',
            'country',
            'postal_code')

    def getContacts(self):
        return Contact.getSome(OR(EQ(FIELD('address_id1'), self.id),
                                  EQ(FIELD('address_id2'), self.id)))


class Contact(PyDO):
    connectionAlias='pim'
    fields=(Sequence('id'),
            'first_name',
            'last_name',
            'address_id1',
            'address_id2',
            'email1',
            'email2',
            'work_phone',
            'home_phone',
            'mobile_phone')

    Address1=ForeignKey('address_id1', 'id', Address)
    Address2=ForeignKey('address_id2', 'id', Address)

    def addNote(self, title, body):
        n=Note.new(title=title, body=body, created=now())
        junction=ContactNote.new(contact_id=self.id,
                                 note_id=n.id)

    getNotes=ManyToMany('id',
                        'contact_note',
                        'contact_id',
                        'note_id',
                        Note,
                        'id')


class ContactNote(PyDO):
    connectionAlias='pim'
    # table is specified here, because the class name
    # is not the same as the table name
    table=&quot;contact_note&quot;
    fields=('contact_id',
            'note_id')
    unique=(('contact_id',
             'note_id'),)

DB=os.environ.get('PIMDB', 'pim.db')
initAlias('pim', 'sqlite', DB)

def initDB():
    joseAddress=Address.new(line1=&quot;43 Chestnut Place&quot;,
                            line2=&quot;Fourth Floor&quot;,
                            town=&quot;Princeton&quot;,
                            state=&quot;NJ&quot;,
                            country=&quot;USA&quot;,
                            postal_code=&quot;06540&quot;)
    jose=Contact.new(first_name='Jose',
                     last_name='Gutenberg',
                     email1='jgutenberg&#64;example.com',
                     address_id1=joseAddress.id,
                     home_phone='609/555-1234')
    jose.addNote('French Tutor',
                 'meet every other Thursday at 7pm in the Annex')
    jose.commit()
    
                     

</pre>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id20" id="differences-from-pydo-1" name="differences-from-pydo-1">10&nbsp;&nbsp;&nbsp;Differences From PyDO 1</a></h1>
<p>This version of PyDO differs in several ways from PyDO version 1.x,
most notably:</p>
<ol class="arabic simple">
<li>PyDO1 defines fields as a tuple of tuples (fieldname, dbtype);
type is  required, as PyDO1 drivers take much of the responsibility
for marshalling Python data types to database types, and does so as
a function of column type.  PyDO2 does not need to know about what
the database type is of the underlying columns, because DBAPI
drivers now largely take care of this themselves.</li>
<li>You cannot define uniqueness constraints in the field list in
PyDO1.</li>
<li>Sequences and auto-increment fields are handled separately in
PyDO1, and both have to be declared in separate class attributes,
which have been dropped in PyDO2.</li>
<li>The <tt class="docutils literal"><span class="pre">SQLOperator</span></tt> syntax is now more flexible, and is accepted by
<tt class="docutils literal"><span class="pre">getSome()</span></tt>. In PyDO1, there are three additional methods that
accept different query syntaxes: <tt class="docutils literal"><span class="pre">getSomeWhere()</span></tt>,
<tt class="docutils literal"><span class="pre">getTupleWhere()</span></tt>, and <tt class="docutils literal"><span class="pre">getSQLWhere()</span></tt>. These have been
dropped.  <tt class="docutils literal"><span class="pre">joinTable()</span></tt> now accepts this query syntax as well,
so it is no longer necessary to override a protected method to
add additional criteria to a join query.</li>
<li>PyDO1 is not thread-safe, and has no connection pool facilities
for multi-threaded use.  What connection management facilities it
does have are tied in with SkunkWeb.  PyDO2 is entirely separate
from SkunkWeb.</li>
<li>PyDO1 uses a different package structure; the new version does not
have the same sub-modules.  However, everything you would normally
need is available in the top-level namespace for both versions.</li>
<li>PyDO1 does not have projections, and the inheritance semantics,
while similar, are not exactly the same.</li>
<li>PyDO1 does not use new-style classes (as it predates them), so the
metaclass functionality is more elaborate, including its own
implementation of class methods (which it calls &quot;static&quot;
methods).</li>
<li>PyDO1 supports more databases than PyDO2 does at the time of
writing.</li>
<li>PyDO2 does not implement PyDO1's original <tt class="docutils literal"><span class="pre">scatterFetch()</span></tt>
method, which returns multiple <tt class="docutils literal"><span class="pre">PyDO</span></tt> objects of different types
in a single query, but has a new function, <tt class="docutils literal"><span class="pre">fetch</span></tt> which has a
superset of the same functionality.</li>
<li>PyDO1 has a variable <tt class="docutils literal"><span class="pre">SYSDATE</span></tt> that means the current
datetime, regardless of the underlying db.  PYDO2 does not
abstract this, as it seems unnecessary now; you can use
something database-dependent like
<tt class="docutils literal"><span class="pre">CONSTANT('CURRENT_TIMESTAMP')</span></tt> or <tt class="docutils literal"><span class="pre">mx.DateTime.now()</span></tt>.</li>
<li>The package name of PyDO in this version is <tt class="docutils literal"><span class="pre">pydo</span></tt>, not
<tt class="docutils literal"><span class="pre">PyDO</span></tt>. Both versions can be installed simultaneously
without any fancy footwork on case-sensitive operating systems; on
case-insensitive OSes, it is still possible to install and use
both, by putting PyDO1 into a zip file, in which paths are always
case-sensitive.  (Thanks to Hamish Lawson for suggesting this
workaround.)</li>
<li>The <tt class="docutils literal"><span class="pre">newfetch()</span></tt> and <tt class="docutils literal"><span class="pre">newnofetch()</span></tt> methods and the
<tt class="docutils literal"><span class="pre">refetch</span></tt> class attribute of <tt class="docutils literal"><span class="pre">PyDO</span></tt> objects are new in PyDO2;
in PyDO1, the <tt class="docutils literal"><span class="pre">refetch</span></tt> keyword argument to <tt class="docutils literal"><span class="pre">new()</span></tt> was used
instead, but was broken for the unlikely case of a column named
&quot;refetch&quot;.</li>
<li>The support of schema-qualified table names and optional guessing
of table name from class name is new in PyDO2.</li>
<li>The optional guessing of field information at runtime, controlled
by the <tt class="docutils literal"><span class="pre">guess_columns</span></tt> attribute, is a new feature in PyDO2.</li>
<li><tt class="docutils literal"><span class="pre">autoschema</span></tt> is new in PyDO2.</li>
<li><tt class="docutils literal"><span class="pre">ForeignKey</span></tt>, <tt class="docutils literal"><span class="pre">OneToMany</span></tt> and <tt class="docutils literal"><span class="pre">ManyToMany</span></tt> are new in PyDO2.</li>
</ol>
<!-- Local Variables:
mode: rst
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="manual.rst">View document source</a>.

</div>
</body>
</html>
